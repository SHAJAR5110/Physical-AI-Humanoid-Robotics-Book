# Chapter 2: ROS 2 Fundamentals

## What is ROS 2?

ROS 2 (Robot Operating System 2) is a flexible middleware framework for building robot applications. It provides:

- **Communication**: Pub/Sub messaging between robot components
- **Hardware Abstraction**: Unified interfaces for different robots
- **Tools**: Visualization, debugging, and monitoring utilities
- **Ecosystem**: Thousands of libraries and packages
- **Standards**: Open-source, vendor-neutral development

ROS 2 is the successor to ROS 1, designed for production robotics with improved:
- Real-time capabilities
- Security
- Scalability
- Multi-robot coordination

## Architecture Overview

ROS 2 follows a **distributed computing model**:

```
┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│   Node 1     │     │   Node 2     │     │   Node 3     │
│  (Sensor)    │     │ (Controller) │     │  (Actuator)  │
└──────┬───────┘     └──────┬───────┘     └──────┬───────┘
       │                    │                    │
       └────────────────────┼────────────────────┘
                   DDS Middleware
                   (Data Distribution Service)
```

**Key Concepts**:

### Nodes
Executables that perform specific tasks (sensor reading, control, planning).

```python
# Example node structure
import rclpy
from rclpy.node import Node

class MinimalPublisher(Node):
    def __init__(self):
        super().__init__('minimal_publisher')
        self.publisher_ = self.create_publisher(String, 'topic', 10)
        self.timer = self.create_timer(0.5, self.timer_callback)

    def timer_callback(self):
        msg = String()
        msg.data = 'Hello from ROS 2!'
        self.publisher_.publish(msg)

def main(args=None):
    rclpy.init(args=args)
    minimal_publisher = MinimalPublisher()
    rclpy.spin(minimal_publisher)

if __name__ == '__main__':
    main()
```

### Topics
Asynchronous communication channels for sensor data and status.

```python
# Subscribing to a topic
def listener_callback(msg):
    self.get_logger().info(f'Received: {msg.data}')

self.subscription = self.create_subscription(String, 'topic', listener_callback, 10)
```

### Services
Synchronous request/response communication for commands and queries.

```python
# Service server
def add_two_ints_callback(request, response):
    response.sum = request.a + request.b
    return response

srv = node.create_service(AddTwoInts, 'add_two_ints', add_two_ints_callback)

# Service client
client = node.create_client(AddTwoInts, 'add_two_ints')
request = AddTwoInts.Request()
request.a = 5
request.b = 3
future = client.call_async(request)
```

### Actions
Long-running tasks with feedback and cancellation.

```python
# Action server (goal-based)
def goal_callback(goal_request):
    if goal_request.order < 0:
        return GoalResponse.REJECTED
    return GoalResponse.ACCEPTED

self.action_server = ActionServer(
    node, Fibonacci, 'fibonacci',
    goal_callback, cancel_callback, execute_callback
)
```

## Installation & Setup

### Ubuntu 22.04 (Recommended)

```bash
# Add ROS 2 repository
sudo apt update
sudo apt install software-properties-common
sudo add-apt-repository universe

# Install ROS 2 Humble
sudo apt update && sudo apt install ros-humble-desktop

# Source setup script
source /opt/ros/humble/setup.bash

# Verify installation
ros2 --version  # Should output "ROS 2 Humble"
```

### macOS Setup

```bash
# Using Homebrew
brew install ros

# Or: Download DMG from https://docs.ros.org/en/humble/Installation.html
```

### Docker Container

```bash
# Run ROS 2 in Docker
docker pull osrf/ros:humble-desktop
docker run -it osrf/ros:humble-desktop
```

## Your First ROS 2 Program

### Step 1: Create a Package

```bash
mkdir -p ~/ros2_ws/src
cd ~/ros2_ws/src
ros2 pkg create --build-type ament_python my_robot_pkg
cd my_robot_pkg
```

### Step 2: Create a Node

Create `my_robot_pkg/my_robot_pkg/talker.py`:

```python
import rclpy
from std_msgs.msg import String

def main(args=None):
    rclpy.init(args=args)
    node = rclpy.create_node('talker')
    publisher = node.create_publisher(String, 'chatter', 10)

    msg = String()
    msg.data = 'Hello, ROS 2 World!'
    publisher.publish(msg)

    node.get_logger().info(f'Publishing: {msg.data}')
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Step 3: Build & Run

```bash
# Build the package
cd ~/ros2_ws
colcon build

# Run the node
source install/setup.bash
ros2 run my_robot_pkg talker
```

## Common Tools

### ros2 topic
Inspect and interact with topics:

```bash
# List all topics
ros2 topic list

# Show topic details
ros2 topic info /chatter

# Echo topic data
ros2 topic echo /chatter

# Publish to a topic
ros2 topic pub /cmd_vel geometry_msgs/Twist "{linear: {x: 0.5}}"
```

### ros2 node
Manage nodes:

```bash
# List running nodes
ros2 node list

# Get node info
ros2 node info /talker
```

### ros2 service
Call ROS 2 services:

```bash
# List services
ros2 service list

# Call a service
ros2 service call /my_service std_srvs/srv/Trigger "{}"
```

### RViz (Visualization)
Visual debugging and monitoring:

```bash
# Launch RViz
rviz2

# Typical setup:
# - Fixed Frame: map
# - Add displays: TF, PointCloud2, MarkerArray
```

## Robot Description (URDF)

Define robot structure using URDF (Unified Robot Description Format):

```xml
<?xml version="1.0"?>
<robot name="my_robot">
  <!-- Base link -->
  <link name="base_link">
    <inertial>
      <mass value="10.0"/>
      <inertia ixx="1.0" ixy="0.0" ixz="0.0" iyy="1.0" iyz="0.0" izz="1.0"/>
    </inertial>
  </link>

  <!-- Wheel link -->
  <link name="wheel_left">
    <inertial>
      <mass value="1.0"/>
      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.1"/>
    </inertial>
  </link>

  <!-- Joint connecting base to wheel -->
  <joint name="wheel_left_joint" type="revolute">
    <parent link="base_link"/>
    <child link="wheel_left"/>
    <axis xyz="0 1 0"/>
    <limit lower="0" upper="10" effort="100" velocity="10"/>
  </joint>
</robot>
```

## ROS 2 Parameter System

Store and access configuration parameters:

```python
# Node with parameters
node.declare_parameter('speed', 1.0)
speed = node.get_parameter('speed').value

# Update parameter
node.set_parameters([Parameter('speed', 2.0)])
```

## Debugging & Troubleshooting

### Common Issues

**Issue**: "Could not find ROS installation"
```bash
# Solution: Source setup script
source /opt/ros/humble/setup.bash
```

**Issue**: "Node not finding topics"
```bash
# Solution: Check ROS domain (different IDs don't communicate)
export ROS_DOMAIN_ID=0
ros2 topic list
```

**Issue**: "Package not found"
```bash
# Solution: Build and source
colcon build
source install/setup.bash
```

## Best Practices

1. **Node Design**
   - Single responsibility per node
   - Use meaningful node and topic names
   - Implement proper shutdown handling

2. **Communication**
   - Topics for high-frequency data (sensors)
   - Services for request/response patterns
   - Actions for long-running tasks

3. **Performance**
   - Use appropriate message frequencies
   - Monitor CPU and memory usage
   - Profile bottlenecks with `ros2 trace`

4. **Safety**
   - Always check service/action availability
   - Implement timeouts for critical operations
   - Use proper error handling

## Next Steps

- **Next Chapter**: Gazebo Simulation - test your ROS 2 code in a virtual environment
- **Practice**: Build a simple publisher/subscriber system
- **Explore**: Try `ros2 demo_nodes_py` for example nodes

---

**Chapter 2 Summary**:
- ROS 2 is middleware for distributed robot systems
- Nodes communicate via Topics (async), Services (sync), and Actions (long-running)
- Standard tools: `ros2 topic`, `ros2 node`, `rviz2`
- URDF describes robot structure and kinematics
- DDS ensures scalability and real-time performance

**Estimated Reading Time**: 25 minutes
**Code Examples**: 8 (publisher, subscriber, service, action)
**Hands-on Exercise**: Create and run your first ROS 2 node
**Next Chapter**: Gazebo Simulation
