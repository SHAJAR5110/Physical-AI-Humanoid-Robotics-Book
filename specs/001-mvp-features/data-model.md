# Phase 1 Design: Data Model & Entity Definitions

**Branch**: `001-mvp-features` | **Date**: 2025-12-06 | **Status**: COMPLETE
**Output of**: `plan.md` Phase 1 design
**Input Sources**: Specification (spec.md), Research (research.md), Technical Context (plan.md)

---

## Executive Summary

Phase 1 defines the canonical data model for the MVP: 6 core entities representing users, chapters, sessions, personalized content, chat history, and embeddings.

**Key Properties**:
- **Normalization**: No redundant data; foreign key relationships enforce referential integrity
- **Idempotency**: Unique constraints prevent duplicate entries (user+chapter → max 1 personalized entry)
- **Audit Trail**: `created_at`, `updated_at` timestamps on all entities for debugging and compliance
- **Performance**: Indexes on frequently queried columns (user_id, chapter_id, session_id)
- **Scalability**: Schema supports growth from 0–100K users during hackathon

---

## Entity Relationship Diagram (ERD)

```
┌──────────────┐         ┌──────────────┐
│    User      │◄────────│   Session    │
│              │ 1:N     │              │
└──────────────┘         └──────────────┘
      │                         │
      │ 1:N                     │ 1:N
      │                         │
      ▼                         ▼
┌──────────────────┐    ┌──────────────────┐
│ Personalized     │    │  Chat Message    │
│ Content          │    │                  │
└──────────────────┘    └──────────────────┘
      │                         │
      │ N:1                     │ N:1
      │                         │
      └──────────┬──────────────┘
                 │ 1:N
                 ▼
          ┌──────────────┐
          │   Chapter    │◄────────────┐
          │              │ 1:N         │
          └──────────────┘             │
                 │                     │
                 │ 1:1                 │
                 ▼                     │
          ┌──────────────────┐         │
          │ Chapter Embedding│─────────┘
          │ (Qdrant)         │
          └──────────────────┘
```

---

## Core Entities

### 1. User

Represents a student or instructor accessing the platform.

```sql
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) NOT NULL UNIQUE,
  name VARCHAR(255) NOT NULL,
  os VARCHAR(50),  -- 'linux', 'macos', 'windows', or NULL
  gpu VARCHAR(100),  -- 'nvidia-rtx-4090', 'apple-m3', etc. or NULL
  experience_level VARCHAR(50),  -- 'beginner', 'intermediate', 'advanced', or NULL
  robotics_background BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),

  -- Constraints
  CONSTRAINT email_not_empty CHECK (length(email) > 0),
  CONSTRAINT name_not_empty CHECK (length(name) > 0)
);

-- Indexes
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_created_at ON users(created_at);
```

**Fields**:
- `id`: Unique identifier (UUID); generated by database
- `email`: User email (unique); from BetterAuth signup
- `name`: User display name
- `os`: Operating system (Linux for ROS 2, macOS, Windows); used for personalization
- `gpu`: GPU model (NVIDIA, Apple Silicon, etc.); used for personalization
- `experience_level`: Self-reported skill level; used for content adaptation
- `robotics_background`: Boolean flag; used for personalization
- `created_at`, `updated_at`: Audit timestamps

**Cardinality**:
- 1 User → N Sessions (user can have multiple concurrent sessions)
- 1 User → N Personalized Content entries (user has personalized version per chapter)
- 1 User → N Chat Messages (chat history per user)

**Uniqueness Constraint**:
- Email is unique (no duplicate sign-ups)

---

### 2. Session

Represents an authenticated login session (BetterAuth + JWT token).

```sql
CREATE TABLE sessions (
  session_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  token_hash VARCHAR(255) NOT NULL UNIQUE,  -- SHA256(JWT token)
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),

  -- Constraints
  CONSTRAINT expires_after_created CHECK (expires_at > created_at)
);

-- Indexes
CREATE INDEX idx_sessions_user_id ON sessions(user_id);
CREATE INDEX idx_sessions_token_hash ON sessions(token_hash);
CREATE INDEX idx_sessions_expires_at ON sessions(expires_at);
```

**Fields**:
- `session_id`: Unique session identifier
- `user_id`: Foreign key to User (cascade delete)
- `token_hash`: SHA256 hash of JWT token (never store plaintext tokens)
- `expires_at`: Session expiration time (24 hours from creation)
- `created_at`: Session creation timestamp

**Cardinality**:
- N Sessions → 1 User (many sessions per user)

**Indexing Strategy**:
- Index on `user_id` for fast session lookup by user
- Index on `token_hash` for fast token validation
- Index on `expires_at` for cleanup queries (expired session deletion)

**Session Lifecycle**:
1. User signs up → BetterAuth creates JWT
2. Backend validates JWT → creates Session record with 24h expiry
3. Frontend stores JWT in localStorage
4. On each API request → frontend sends JWT in Authorization header
5. Backend verifies token (check `token_hash` in sessions table) → allow request
6. On logout → delete Session record (or frontend clears localStorage)
7. Scheduled cleanup job removes expired sessions (> 24h old)

---

### 3. Chapter

Represents a chapter in the 6-chapter book (static content, versioned).

```sql
CREATE TABLE chapters (
  id SERIAL PRIMARY KEY,
  title VARCHAR(255) NOT NULL,
  slug VARCHAR(255) NOT NULL UNIQUE,  -- 'intro', 'ros2', 'gazebo', 'isaac', 'vla', 'capstone'
  content TEXT NOT NULL,  -- Full markdown content
  summary TEXT,  -- 200-word excerpt for preview
  author VARCHAR(255),  -- Author name or "Community"
  version VARCHAR(10) DEFAULT '1.0',  -- Semantic versioning for content updates
  page_count INT,  -- Derived: word count / 250
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),

  -- Constraints
  CONSTRAINT title_not_empty CHECK (length(title) > 0),
  CONSTRAINT content_not_empty CHECK (length(content) > 0)
);

-- Indexes
CREATE INDEX idx_chapters_slug ON chapters(slug);
CREATE INDEX idx_chapters_created_at ON chapters(created_at);
```

**Fields**:
- `id`: Chapter ID (1–6 for MVP)
- `title`: Chapter title (e.g., "Introduction to Physical AI")
- `slug`: URL-friendly identifier (e.g., "intro")
- `content`: Full markdown content (includes code blocks, images, LaTeX)
- `summary`: Short preview (used in book catalog)
- `author`: Chapter author or "Community"
- `version`: Semantic version (allows tracking updates; embeddings refresh on version bump)
- `page_count`: Estimated pages (used for progress tracking)
- `created_at`, `updated_at`: Audit timestamps

**Cardinality**:
- 1 Chapter → N Personalized Content entries (chapter has personalized versions for multiple users)
- 1 Chapter → 1 Chapter Embedding (one embedding vector per chapter)
- 1 Chapter → N Chat Messages (chapter context in chat history)

**Content Lifecycle**:
1. Chapter authored in markdown (locally, reviewed, committed to Git)
2. On deployment → backend reads `docs/{slug}.md` from Git
3. Insert/update in `chapters` table (version bumped on content change)
4. Batch job: embed new/updated chapters → store in Qdrant
5. Frontend: fetch chapter list (GET /chapters) → display in Docusaurus sidebar

---

### 4. Personalized Content

Represents a user's personalized rewrite of a chapter (cached LLM output).

```sql
CREATE TABLE personalized_content (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  chapter_id INT NOT NULL REFERENCES chapters(id) ON DELETE CASCADE,
  personalized_text TEXT NOT NULL,  -- Claude API output
  model_version VARCHAR(50) DEFAULT 'claude-3-5-haiku-20241022',  -- LLM version used
  cache_source VARCHAR(50),  -- 'claude-api' or 'database'
  created_at TIMESTAMP DEFAULT NOW(),
  expires_at TIMESTAMP DEFAULT NOW() + INTERVAL '30 days',  -- Cache TTL

  -- Constraints
  CONSTRAINT user_chapter_unique UNIQUE (user_id, chapter_id),  -- Max 1 per user+chapter
  CONSTRAINT expires_after_created CHECK (expires_at > created_at),
  CONSTRAINT personalized_text_not_empty CHECK (length(personalized_text) > 0)
);

-- Indexes
CREATE INDEX idx_personalized_content_user_id ON personalized_content(user_id);
CREATE INDEX idx_personalized_content_chapter_id ON personalized_content(chapter_id);
CREATE INDEX idx_personalized_content_expires_at ON personalized_content(expires_at);
CREATE INDEX idx_personalized_content_user_chapter ON personalized_content(user_id, chapter_id);
```

**Fields**:
- `id`: Unique entry identifier
- `user_id`: Foreign key to User (cascade delete)
- `chapter_id`: Foreign key to Chapter (cascade delete)
- `personalized_text`: Claude API output (rewritten content)
- `model_version`: LLM version used (allows tracking quality per model)
- `cache_source`: Where the content came from ('claude-api' = just generated, 'database' = retrieved from cache)
- `created_at`: Generation timestamp
- `expires_at`: Cache expiration (30-day TTL; after this, user must re-generate)

**Cardinality**:
- N Personalized Content → 1 User
- N Personalized Content → 1 Chapter

**Uniqueness Constraint**:
- `UNIQUE (user_id, chapter_id)` ensures max 1 personalized version per user per chapter
- If user clicks "Personalize" again, UPDATE existing entry (not INSERT)

**Cache Lifecycle**:
1. User clicks "Personalize" button on Chapter 1
2. Backend checks: does personalized_content entry exist for (user_id, chapter_1_id)?
   - **Cache hit**: return cached `personalized_text`, set `cache_source='database'`
   - **Cache miss**: call Claude API → generate rewrite → INSERT/UPDATE → return
3. Cleanup job: delete expired entries (expires_at < NOW())

**Fallback on Cache Miss**:
- In-memory cache miss (instance restarted) → query Postgres → cache hit
- Postgres miss (cache expired) → generate from Claude API (slower but correct)

---

### 5. Chat Message

Represents a message in the RAG chatbot (user question + assistant response + citations).

```sql
CREATE TABLE chat_messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  chapter_id INT NOT NULL REFERENCES chapters(id) ON DELETE CASCADE,
  user_message TEXT NOT NULL,
  assistant_response TEXT NOT NULL,
  citations TEXT,  -- JSON array: [{"chapter_id": 1, "section": "2.1", "excerpt": "..."}, ...]
  source_chapters TEXT,  -- JSON array of chapter IDs used in RAG
  tokens_used INT,  -- For cost tracking
  created_at TIMESTAMP DEFAULT NOW(),

  -- Constraints
  CONSTRAINT user_message_not_empty CHECK (length(user_message) > 0),
  CONSTRAINT assistant_response_not_empty CHECK (length(assistant_response) > 0)
);

-- Indexes
CREATE INDEX idx_chat_messages_user_id ON chat_messages(user_id);
CREATE INDEX idx_chat_messages_chapter_id ON chat_messages(chapter_id);
CREATE INDEX idx_chat_messages_created_at ON chat_messages(created_at);
```

**Fields**:
- `id`: Unique message ID
- `user_id`: Foreign key to User
- `chapter_id`: Chapter being discussed (user initiated chat from Chapter 1 context)
- `user_message`: User's question/prompt
- `assistant_response`: Claude API response
- `citations`: JSON array of citation objects:
  ```json
  [
    {"chapter_id": 1, "section": "Introduction", "excerpt": "Physical AI combines..."},
    {"chapter_id": 3, "section": "Gazebo Basics", "excerpt": "Gazebo is a simulator..."}
  ]
  ```
- `source_chapters`: JSON array of chapter IDs used in RAG retrieval (for debugging)
- `tokens_used`: Token count (for cost tracking and rate limiting)
- `created_at`: Message timestamp

**Cardinality**:
- N Chat Messages → 1 User (chat history per user)
- N Chat Messages → 1 Chapter (context of where chat was initiated)

**Chat Lifecycle**:
1. User types question in chatbot widget (context: Chapter 1)
2. Backend embeds question → Qdrant semantic search (top-5 chapters)
3. Format RAG prompt with top-5 excerpts
4. Call Claude API → get response + citations
5. INSERT Chat Message (user_message, assistant_response, citations)
6. Return response to frontend with citations displayed as footnotes

**Validation**:
- SC-006 acceptance: Every citation in `citations` array must exist in `chapters.content`
- Test: POST /chat → response → verify each citation matches chapter text

---

### 6. Chapter Embedding

Represents vectorized chapter content for semantic search (stored in Qdrant; metadata in Postgres).

```sql
CREATE TABLE chapter_embeddings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  chapter_id INT NOT NULL REFERENCES chapters(id) ON DELETE CASCADE,
  section_title VARCHAR(255),  -- e.g., "2.1 ROS 2 Architecture"
  section_index INT,  -- Order within chapter (1-indexed)
  content_excerpt TEXT,  -- ~500 words of content
  embedding_model VARCHAR(50) DEFAULT 'claude-embeddings-3',
  vector_dimensions INT DEFAULT 1024,
  qdrant_point_id UUID,  -- Reference to Qdrant collection
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),

  -- Constraints
  CONSTRAINT chapter_section_unique UNIQUE (chapter_id, section_index),
  CONSTRAINT content_excerpt_not_empty CHECK (length(content_excerpt) > 0)
);

-- Indexes
CREATE INDEX idx_chapter_embeddings_chapter_id ON chapter_embeddings(chapter_id);
CREATE INDEX idx_chapter_embeddings_qdrant_point_id ON chapter_embeddings(qdrant_point_id);
```

**Fields**:
- `id`: Unique embedding record ID (in Postgres)
- `chapter_id`: Foreign key to Chapter
- `section_title`: Section within chapter (e.g., "2.1 Architecture")
- `section_index`: Order (for reconstruction of full chapter)
- `content_excerpt`: ~500 words of actual text (for citation display)
- `embedding_model`: Which embedding model generated the vector
- `vector_dimensions`: Dimensionality of vector (1024 for Claude, 1536 for OpenAI)
- `qdrant_point_id`: Reference to vector in Qdrant (actual vector stored in Qdrant, not Postgres)
- `created_at`, `updated_at`: Audit timestamps

**Cardinality**:
- 1 Chapter → N Chapter Embeddings (chapter split into 5–10 sections; each gets embedding)

**Embedding Workflow**:
1. On deployment: batch job reads all chapters from `chapters` table
2. For each chapter:
   - Split content into ~500-word sections
   - For each section: embed via Claude embeddings API
   - Store metadata in `chapter_embeddings` (Postgres)
   - Store vector in Qdrant (Qdrant collection: `chapters`, point_id = UUID)
3. Qdrant metadata payload includes:
   ```json
   {
     "chapter_id": 1,
     "section_title": "2.1 ROS 2 Architecture",
     "section_index": 1,
     "excerpt": "ROS 2 (Robot Operating System) is a distributed framework...",
     "postgres_id": "uuid-of-chapter-embeddings-record"
   }
   ```

**Retrieval in RAG**:
1. User question → embed via Claude embeddings API → search Qdrant
2. Qdrant returns top-5 points with scores + metadata
3. Extract `excerpt` from Qdrant metadata → include in RAG prompt
4. Response includes citations referencing `chapter_id` + `section_title`

---

## Schema Diagram (SQL)

```sql
-- Users table
users (
  id UUID PRIMARY KEY,
  email VARCHAR UNIQUE,
  name VARCHAR,
  os VARCHAR,
  gpu VARCHAR,
  experience_level VARCHAR,
  robotics_background BOOLEAN,
  created_at, updated_at
)

-- Sessions table (auth)
sessions (
  session_id UUID PRIMARY KEY,
  user_id UUID FK → users(id),
  token_hash VARCHAR UNIQUE,
  expires_at TIMESTAMP,
  created_at
)

-- Chapters table (static content)
chapters (
  id SERIAL PRIMARY KEY,
  title VARCHAR UNIQUE,
  slug VARCHAR UNIQUE,
  content TEXT,
  summary TEXT,
  author VARCHAR,
  version VARCHAR,
  page_count INT,
  created_at, updated_at
)

-- Personalized Content (cached LLM output)
personalized_content (
  id UUID PRIMARY KEY,
  user_id UUID FK → users(id),
  chapter_id INT FK → chapters(id),
  personalized_text TEXT,
  model_version VARCHAR,
  cache_source VARCHAR,
  created_at, expires_at,
  UNIQUE (user_id, chapter_id)
)

-- Chat Messages (RAG history)
chat_messages (
  id UUID PRIMARY KEY,
  user_id UUID FK → users(id),
  chapter_id INT FK → chapters(id),
  user_message TEXT,
  assistant_response TEXT,
  citations JSON,
  source_chapters JSON,
  tokens_used INT,
  created_at
)

-- Chapter Embeddings (metadata for Qdrant)
chapter_embeddings (
  id UUID PRIMARY KEY,
  chapter_id INT FK → chapters(id),
  section_title VARCHAR,
  section_index INT,
  content_excerpt TEXT,
  embedding_model VARCHAR,
  vector_dimensions INT,
  qdrant_point_id UUID,
  created_at, updated_at,
  UNIQUE (chapter_id, section_index)
)
```

---

## Constraints & Validation

### Referential Integrity
- `ON DELETE CASCADE`: If user deleted → delete all sessions, personalized content, chat messages
- `ON DELETE CASCADE`: If chapter deleted → delete all personalized content, chat messages, embeddings
- Foreign keys enforced at database level

### Uniqueness Constraints
- `users.email`: No duplicate sign-ups
- `chapters.slug`: One slug per chapter (unique URL)
- `personalized_content (user_id, chapter_id)`: Max 1 cached version per user per chapter
- `chapter_embeddings (chapter_id, section_index)`: Max 1 embedding per section

### Check Constraints
- Timestamps: `expires_at > created_at`, `updated_at >= created_at`
- Non-empty strings: `length(field) > 0`
- Valid JSON: `citations` and `source_chapters` are JSON arrays (validated in application)

---

## Indexes for Performance

| Index | Table | Columns | Purpose |
|-------|-------|---------|---------|
| `idx_users_email` | users | email | Fast lookup by email (signup, signin) |
| `idx_sessions_user_id` | sessions | user_id | Find all sessions for a user |
| `idx_sessions_token_hash` | sessions | token_hash | Validate JWT token |
| `idx_sessions_expires_at` | sessions | expires_at | Cleanup expired sessions |
| `idx_chapters_slug` | chapters | slug | Fetch chapter by URL slug |
| `idx_personalized_content_user_id` | personalized_content | user_id | Fetch all personalized content for user |
| `idx_personalized_content_user_chapter` | personalized_content | (user_id, chapter_id) | Check cache hit (composite index) |
| `idx_chat_messages_user_id` | chat_messages | user_id | Fetch chat history for user |
| `idx_chapter_embeddings_chapter_id` | chapter_embeddings | chapter_id | Fetch embeddings for chapter |

---

## Migration Strategy (Alembic)

```
backend/src/db/migrations/
├── versions/
│   ├── 001_create_users_table.py
│   ├── 002_create_sessions_table.py
│   ├── 003_create_chapters_table.py
│   ├── 004_create_personalized_content_table.py
│   ├── 005_create_chat_messages_table.py
│   └── 006_create_chapter_embeddings_table.py
└── env.py
```

**Deployment**:
```bash
# On every deployment
alembic upgrade head
```

---

## Example Data (for testing)

### User
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440001",
  "email": "alice@example.com",
  "name": "Alice Chen",
  "os": "linux",
  "gpu": "nvidia-rtx-4090",
  "experience_level": "intermediate",
  "robotics_background": true
}
```

### Session
```json
{
  "session_id": "650e8400-e29b-41d4-a716-446655440002",
  "user_id": "550e8400-e29b-41d4-a716-446655440001",
  "token_hash": "sha256(eyJhbGc...)",
  "expires_at": "2025-12-07T14:30:00Z",
  "created_at": "2025-12-06T14:30:00Z"
}
```

### Chapter
```json
{
  "id": 1,
  "title": "Introduction to Physical AI",
  "slug": "intro",
  "content": "# Introduction to Physical AI\n\nPhysical AI combines robotics with...",
  "summary": "An overview of Physical AI, combining robotics, control systems, and AI.",
  "author": "Dr. Pieter Abbeel",
  "version": "1.0",
  "page_count": 12,
  "created_at": "2025-12-06T00:00:00Z"
}
```

### Personalized Content
```json
{
  "id": "750e8400-e29b-41d4-a716-446655440003",
  "user_id": "550e8400-e29b-41d4-a716-446655440001",
  "chapter_id": 1,
  "personalized_text": "# Introduction to Physical AI (Optimized for Linux NVIDIA RTX 4090)\n\nFor your setup with a high-end GPU, Physical AI is an exciting field...",
  "model_version": "claude-3-5-haiku-20241022",
  "cache_source": "claude-api",
  "created_at": "2025-12-06T14:30:00Z",
  "expires_at": "2026-01-05T14:30:00Z"
}
```

---

## Success Criteria Alignment

| Criterion | Satisfied By | Status |
|-----------|--------------|--------|
| SC-002: Signup <2min | User + Session tables with BetterAuth | ✅ |
| SC-003: Personalization caching | personalized_content table + TTL | ✅ |
| SC-004: Translation caching | personalized_content table (reuse) | ✅ |
| SC-005: Chatbot responses | Chapter Embedding + Chat Message tables | ✅ |
| SC-006: 100% citations | citations JSON field in Chat Message | ✅ |
| SC-007: 100 concurrent users | Index strategy supports fast queries | ✅ |
| SC-008: 24h session timeout | Session.expires_at constraint | ✅ |
| SC-009: 90% success rate | Referential integrity + error handling | ✅ |
| SC-011: No plain-text passwords | BetterAuth (no password storage) | ✅ |

---

## Next Steps

1. **Generate API Contracts** (`contracts/api.yaml`): Define REST endpoints for user, chapter, personalization, translation, chat operations
2. **Generate Quickstart** (`quickstart.md`): Step-by-step setup (create tables, load data, run migrations)
3. **Task Breakdown** (`/sp.tasks`): Decompose Phase 1 into ~15 implementable tasks (models, migrations, schema validation)

---

## Reflection

The data model is minimal, normalized, and optimized for the MVP:
- **6 entities** capturing all required state (user, session, chapter, personalized, chat, embedding)
- **Foreign keys + cascading deletes** ensure data consistency
- **Indexes** on frequently queried columns (user_id, chapter_id, token_hash, email)
- **Unique constraints** prevent duplicates (user+chapter for personalization, email for users)
- **TTL caching** on personalized content (30-day expiry) reduces LLM API calls
- **Embedding metadata** stored in Postgres; actual vectors in Qdrant (separation of concerns)

No architectural unknowns remain in data modeling. Ready to generate API contracts.
